#!/bin/bash -eu
# ex:ts=4:sw=4:sts=4:et
# -*- tab-width: 4; c-basic-offset: 4; indent-tabs-mode: nil -*-
#
# patchtest-test-mboxes: (patch) Test the provided mboxes and if required,
#                        assemble those that can be merged into a branch
#                        with results as git-notes
#
# Copyright (C) 2016 Intel Corporation
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 2 as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

# default values
verbose=''
repodir=''
startdir=''
assemblebranch=''
startpoint='HEAD'
outrepodir=''

function usage() {
    cat << EOF
\$ $(basename $0) -v -r <repodir> -s <startdir> -a <assemble branch> -p <start point> -o <outrepodir> (mboxdir | <patch>) ...

where

    <repodir>         : Repository
    <startdir>        : Start directory for test discovery
    <assemble branch> : Branch name to assemble patches (that can be merged), including results as git-notes
    <start point>     : Start point for assemble branch. Defaults to $startpoint
    <outrepodir>      : Output git repository for patchtest results, created if it does not exist. Defaults to $outrepodir
    <mboxdir>         : Directory containing mboxes
    <patch>           : Patch to test by patchtest.
EOF
>&2

    exit 1
}

function gitnotes() {
    git notes --ref=patchtest-results-failure add -m "$(echo "$PTRESULTS" | grep FAIL)" HEAD
    git notes --ref=patchtest-results-skip    add -m "$(echo "$PTRESULTS" | grep SKIP)" HEAD
    git notes --ref=patchtest-results-pass    add -m "$(echo "$PTRESULTS" | grep PASS)" HEAD
    git notes --ref=patchtest-log add -m "$PTLOG" HEAD
}

function testpatch() {
    local patch="$1"

    echo -e "${patch}"

    tmp="$(mktemp)"
    # run patchtest
    PTRESULTS="$(patchtest $patch --repo-dir $repodir --start-dir $startdir 2>$tmp)"
    PTLOG="$(cat $tmp)"
    rm $tmp

    if [ -n "$outrepodir" ]; then
	patchfn=$(basename $patch)

	# just create a commit if patch is not tracked yet
	test ! -f $patchfn && {
	    cp $patch $outrepodir/$patchfn
	    # go to the output repo and create a commit with git-notes
	    ( cd $outrepodir; git add $patchfn; git commit -s -m "$patch"; gitnotes );
	    echo -e "\tResults stored into '$outrepodir'";
	} || { echo -e "\tAlready tested"; }
    fi

    if [ -n "$assemblebranch" ]; then
	# if assemble branch give, try to assemble as many as possible

	# move the assemblebranch
	git checkout $assemblebranch --quiet

	# try patch merge
	if git apply --check $patch 2> /dev/null; then
	    git am --quiet $patch 2> /dev/null
	    gitnotes
	    echo -e "\tPatch merged into '${assemblebranch}' with results as git-notes"
	else
	    echo -e "\tNot merged due to a merge-conflict"
	fi
	git checkout $CURRENTB --quiet
    fi

    if [ -n "$verbose" ]; then
	echo -e "$PTLOG"
	echo -e "$PTRESULTS"
    fi

    echo -e ""
}

while getopts ":r:s:p:a:o:vh" opt; do
    case $opt in
	r)
	    repodir=$OPTARG
	    ;;
	s)
	    startdir=$OPTARG
	    ;;
	p)
	    startpoint=$OPTARG
	    ;;
	a)
	    assemblebranch=$OPTARG
	    ;;
	o)
	    outrepodir=$OPTARG
	    ;;
	v)
	    verbose='x'
	    ;;
	h)
	    usage
	    ;;
	\?)
	    echo "Invalid option: -$OPTARG" >&2
	    usage
	    ;;
	:)
	    echo "Option -$OPTARG requires an argument." >&2
	    usage
	    ;;
    esac
done
shift $((OPTIND-1))

# check input data presence
test -z "$@" && { echo -e "Provide at least a patch or a patch directory"; usage; }

test -z "$repodir"  && { echo "Indicate the repository"; usage; }
test ! -d $repodir  && { echo "Repository does not exit"; usage; }
test ! -d $startdir && { echo "Test suite starting directory does not exist"; usage; }
test ! -d $outrepodir && { (mkdir -p $outrepodir; cd $outrepodir;  git init) }

# check if outrepodir is a git repo
test ! -d $outrepodir/.git && { echo "$outrepodir is not a git repo"; usage; }

# get current branch
CURRENTB=$(git rev-parse --abbrev-ref HEAD)

# create assemblebrach
if [ -n "$assemblebranch" ]; then
    git branch $assemblebranch $startpoint
fi

for item in "$@"; do
    # if item is a directory, get all files and test each
    if [ -d $item ]; then
	for patch in $(find $item -type f | sort -n); do
	    testpatch $patch
	done
    else
	testpatch $item
    fi
done
